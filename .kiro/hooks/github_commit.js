// .kiro/hooks/github_commit.js - GitHub commit and PR creation hook
const { Octokit } = require('@octokit/rest');

/**
 * Commits a fixed file to GitHub and creates a pull request
 * 
 * Usage example:
 * const result = await commitFix({
 *   owner: 'myusername',
 *   repo: 'my-project',
 *   baseBranch: 'main',
 *   newBranchName: 'bug-whisperer-fix-123',
 *   path: 'src/app.js',
 *   content: 'const x = 5;\nconsole.log(x);\n',
 *   commitMessage: 'Fix ESLint issues in app.js'
 * });
 * console.log(result.pullRequestUrl);
 * 
 * @param {Object} params - Commit parameters
 * @param {string} params.owner - Repository owner (username or organization)
 * @param {string} params.repo - Repository name
 * @param {string} params.baseBranch - Base branch to create PR into (e.g., 'main')
 * @param {string} params.newBranchName - New branch name for the fix
 * @param {string} params.path - File path within the repository
 * @param {string} params.content - File content (plain text, will be base64 encoded)
 * @param {string} params.commitMessage - Commit message
 * @returns {Promise<Object>} Object with commit and pull request details
 * @throws {Error} If GitHub API error occurs or permissions are insufficient
 */
async function commitFix({ owner, repo, baseBranch, newBranchName, path, content, commitMessage }) {
  // Validate GitHub token
  if (!process.env.GITHUB_TOKEN) {
    throw new Error('GITHUB_TOKEN environment variable is required. Please set it in your .env file.');
  }

  // Initialize Octokit client
  const octokit = new Octokit({
    auth: process.env.GITHUB_TOKEN,
    userAgent: 'Bug Whisperer GitHub Commit Hook v1.0.0'
  });

  try {
    // Step 1: Get the base branch reference
    const baseBranchRef = await octokit.rest.git.getRef({
      owner,
      repo,
      ref: `heads/${baseBranch}`
    });

    // Step 2: Create new branch from base branch
    try {
      await octokit.rest.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${newBranchName}`,
        sha: baseBranchRef.data.object.sha
      });
    } catch (error) {
      if (error.status === 422) {
        throw new Error(`Branch '${newBranchName}' already exists. Please use a different branch name.`);
      }
      throw error;
    }

    // Step 3: Create blob with file content (base64 encoded)
    const blob = await octokit.rest.git.createBlob({
      owner,
      repo,
      content: Buffer.from(content).toString('base64'),
      encoding: 'base64'
    });

    // Step 4: Get current tree from base branch
    const baseCommit = await octokit.rest.git.getCommit({
      owner,
      repo,
      commit_sha: baseBranchRef.data.object.sha
    });

    // Step 5: Create new tree with updated file
    const newTree = await octokit.rest.git.createTree({
      owner,
      repo,
      base_tree: baseCommit.data.tree.sha,
      tree: [
        {
          path: path,
          mode: '100644',
          type: 'blob',
          sha: blob.data.sha
        }
      ]
    });

    // Step 6: Create commit on new branch
    const newCommit = await octokit.rest.git.createCommit({
      owner,
      repo,
      message: commitMessage,
      tree: newTree.data.sha,
      parents: [baseBranchRef.data.object.sha],
      author: {
        name: 'Bug Whisperer',
        email: 'bug-whisperer@users.noreply.github.com',
        date: new Date().toISOString()
      }
    });

    // Step 7: Update new branch reference to point to new commit
    await octokit.rest.git.updateRef({
      owner,
      repo,
      ref: `heads/${newBranchName}`,
      sha: newCommit.data.sha
    });

    // Step 8: Create pull request
    const pullRequest = await octokit.rest.pulls.create({
      owner,
      repo,
      title: `Bug Whisperer: ${commitMessage}`,
      body: `## üêõ Bug Whisperer Auto-Fix

This pull request contains automatic fixes for JavaScript issues detected by Bug Whisperer.

**File changed:** \`${path}\`
**Issues fixed:** ESLint violations and code quality improvements

The fixes have been automatically applied and tested. Please review the changes before merging.

---
*Generated by Bug Whisperer*`,
      head: newBranchName,
      base: baseBranch
    });

    return {
      success: true,
      branchName: newBranchName,
      commitSha: newCommit.data.sha,
      commitUrl: newCommit.data.html_url,
      pullRequestNumber: pullRequest.data.number,
      pullRequestUrl: pullRequest.data.html_url
    };

  } catch (error) {
    // Handle specific GitHub API errors
    if (error.status === 404) {
      throw new Error(`Repository ${owner}/${repo} not found or base branch '${baseBranch}' does not exist.`);
    }
    
    if (error.status === 403) {
      throw new Error(`Access denied to ${owner}/${repo}. Please check your GitHub token has write permissions.`);
    }
    
    if (error.status === 401) {
      throw new Error('GitHub authentication failed. Please check your GITHUB_TOKEN is valid and has not expired.');
    }

    // Re-throw other errors with context
    throw new Error(`GitHub API error: ${error.message}`);
  }
}

module.exports = { commitFix };